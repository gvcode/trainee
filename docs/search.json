[
  {
    "objectID": "aula1-python1.html",
    "href": "aula1-python1.html",
    "title": "1¬† Introdu√ß√£o ao Python I",
    "section": "",
    "text": "Introdu√ß√£o\nNesta aula, vamos aprender desde o b√°sico, sintaxe, tomada de decis√µes, repeti√ß√£o de a√ß√µes, e estruturar melhor nossos programas, para que eles possam lidar com diferentes situa√ß√µes de forma din√¢mica.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python I</span>"
    ]
  },
  {
    "objectID": "aula1-python1.html#introdu√ß√£o",
    "href": "aula1-python1.html#introdu√ß√£o",
    "title": "1¬† Introdu√ß√£o ao Python I",
    "section": "",
    "text": "Sintaxe e Scripts B√°sicos\nTipos de Dados em Python\nOperadores em Python\nControle de Fluxo\nFun√ß√µes\nTratamento de Erros",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python I</span>"
    ]
  },
  {
    "objectID": "aula1-python1.html#porque-python",
    "href": "aula1-python1.html#porque-python",
    "title": "1¬† Introdu√ß√£o ao Python I",
    "section": "1.1 Porque Python?",
    "text": "1.1 Porque Python?\nPython √© uma linguagem de programa√ß√£o f√°cil de aprender, com uma sintaxe clara e intuitiva, ideal para iniciantes. √â amplamente utilizada em diversas √°reas, como ci√™ncia de dados, desenvolvimento web e automa√ß√£o, tornando-se uma ferramenta vers√°til e pr√°tica.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python I</span>"
    ]
  },
  {
    "objectID": "aula1-python1.html#sintaxe",
    "href": "aula1-python1.html#sintaxe",
    "title": "1¬† Introdu√ß√£o ao Python I",
    "section": "1.2 Sintaxe",
    "text": "1.2 Sintaxe\n\n\n1.2.1 Scripts\nUm script √© um arquivo de texto com instru√ß√µes a serem executadas por um computador que antes traduzir√° o arquivo para linguagem de m√°quina.\nUm script √© um texto instrucional como qualquer outro, escrito em um tipo de linguagem especial, ‚Äúde programa√ß√£o‚Äù, ou ‚Äúc√≥digo‚Äù, mas √© um texto, quase como uma receita de bolo de cenoura.\nComo em qualquer linguagem, temos um vocabul√°rio √† disposi√ß√£o, um conjunto de palavras (ou tokens) existentes, organizadas em categorias como substantivos, adjetivos, etc. N√≥s combinamos as palavras em frases (ou statements) para descrever as instru√ß√µes. Por fim, organizamos o texto em par√°grafos (ou blocks), conjuntos de frases que devem ser lidas juntas, para definir a estrutura e facilitar o entendimento do texto.\n\n\n\n1.2.2 Sintaxe B√°sica\nA sintaxe dentro do Python √© muito semelhante com a linguagem humana. O programa ‚Äúl√™‚Äù de cima para baixo, da esqueda para a direita de forma sequencial!\nNote ao longo dos programas: espa√ßos, quebras de linha, tabs, coment√°rios‚Ä¶\n\n#Vamos fazer essa soma!\n\nsoma = 2 + 2 # soma bem facil...\nsoma2=2+2\n\nprint(soma, soma2)\n\n4 4",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python I</span>"
    ]
  },
  {
    "objectID": "aula1-python1.html#vari√°veis",
    "href": "aula1-python1.html#vari√°veis",
    "title": "1¬† Introdu√ß√£o ao Python I",
    "section": "1.3 Vari√°veis",
    "text": "1.3 Vari√°veis\n\nAs vari√°veis no python s√£o bem parecidas com as vari√°veis da matem√°tica. Serve como caixinhas que carregam algo dentro e, sempre que o programa ler ela, entender√° o seu conte√∫do.\nx = \"julia\"  #toda vez que o programa ler x, ler√° a string julia\ny = 5        #toda vez que o programa ler y, ler√° o n√∫mero inteiro 5\nz = 2.5      #toda vez que o programa ler z, ler√° o n√∫mero float 2,5\nVari√°veis s√£o um nome, associado √† um valor, que mora na mem√≥ria do computador.\nTenha em mente ao nomear uma vari√°vel que: - N√£o se pode usar os termos reservados;\n\nNomes de vari√°veis podem conter apenas letras, n√∫meros e underscores(_). Podem come√ßar com uma letra ou um underscore, mas n√£o com um n√∫mero;\nEspa√ßos n√£o s√£o permitidos em nomes de vari√°veis (usa-se underscores para separa as palavras);\nDicas: nomes de vari√°veis devem ser concisos, por√©m descritivos.\n\nNa pr√°tica, quando escrevemos essas var√≠aveis, n√∫meros e strings em c√©lulas de c√≥digo, observamos diferentes cores que indicam o que o python est√° enxergando.\nTermos reservados s√£o termos que j√° possuem um ‚Äúsignificado‚Äù para o Python, ent√£o n√£o podemos usa-los como vari√°veis.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python I</span>"
    ]
  },
  {
    "objectID": "aula1-python1.html#tipos-de-dados",
    "href": "aula1-python1.html#tipos-de-dados",
    "title": "1¬† Introdu√ß√£o ao Python I",
    "section": "1.4 Tipos de Dados",
    "text": "1.4 Tipos de Dados\nTipos de dados s√£o os ‚Äútijolinhos‚Äù b√°sicos que formam nossos programas. Eles representam os diferentes tipos de informa√ß√µes que podemos armazenar e manipular, como textos, n√∫meros e valores l√≥gicos. Cada tipo de dado √© salvo de uma forma espec√≠fica na mem√≥ria, permitindo que realizemos opera√ß√µes adequadas para cada tipo.\nNesta aula, vamos explorar os principais tipos de dados em Python. Para se aprofundar mais: https://docs.python.org/3/library/datatypes.html\n\n\n\n\n\n1.4.1 String\nUma string √© um ‚Äúdesenho‚Äù, onde o programa n√£o enxerga nenhum valor num√©rico mas consegue diferir os ‚Äúdesenhos‚Äù entre si. Seu s√≠mbolo √© ‚Äô ‚Äô ou ‚Äù ‚Äú, indicando ao programa que √© uma string. Um n√∫mero pode ter valor num√©rico (int ou float por exemplo) ou n√£o (str).\nObs: o python √© uma linguagem extremamente sens√≠vel, ent√£o a string ‚Äújulia‚Äù e a string ‚ÄúJulia‚Äù n√£o s√£o iguais para ele.\n\"Julia\"\n\"luana\"\n\"123456\"\nUma ferramenta que voc√™s usar√£o e que ‚Äúrespiram‚Äù strings √© o len().\n‚ÄúLen‚Äù √© a brevia√ß√£o para a palavra Length, ou seja, comprimento, e √© exatamente o que ele mede: essa fun√ß√£o retorna o n√∫mero de caract√©res de uma string.\nObs: os ESPA√áOS contam como caracteres.\nlen(\"julia cruz\") --&gt; retorna o n√∫mero 10 (um inteiro)\n\n\n1.4.2 Inteiro\nOs inteiros s√£o n√∫meros que n√£o s√£o strings e n√£o possuem valor depois da v√≠gula, ou seja, s√£o n√∫meros inteiros :D. Usados em express√µes matem√°ticas para contas.\n5\n6\n12\n1000\n\n\n1.4.3 Float\nS√£o semelhantes aos n√∫meros inteiros por√©m considera e demanda valores depois da v√≠rgula, mesmo que seja 0. Se misturam com os inteiros em equa√ß√µes matem√°ticas.\n1.0\n2.3\n45.002\n1000.0\n\n\n1.4.4 Booleano\nUm valor booleano √© um tipo de dado que pode representar apenas dois estados distintos: verdadeiro ou falso. √â fundamental em muitos aspectos da programa√ß√£o e da l√≥gica, pois permite tomar decis√µes com base em condi√ß√µes.\nverdadeiro = True\nfalso = False",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python I</span>"
    ]
  },
  {
    "objectID": "aula1-python1.html#operadores",
    "href": "aula1-python1.html#operadores",
    "title": "1¬† Introdu√ß√£o ao Python I",
    "section": "1.5 Operadores",
    "text": "1.5 Operadores\nS√£o s√≠mbolos que nos permitem realizar opera√ß√µes sobre vari√°veis e valores. Eles s√£o fundamentais para a constru√ß√£o de express√µes em Python, ajudando a manipular dados, fazer c√°lculos e tomar decis√µes.\nMaterial base e aprofundamento: https://docs.python.org/3/library/operator.html  \n\n\n1.5.1 Operadores Aritim√©ticos\nOs operadores aritm√©ticos s√£o usados para realizar opera√ß√µes matem√°ticas entre operandos.\n\n\n\n\nimage.png\n\n\n\nprint(2+2)\n\n4\n\n\n\nprint(2*5 - 7)\n\n3\n\n\n\nprint(4%2)\n\n0\n\n\n\nprint(3%2)\n\n1\n\n\n\ndivisao_inteira = 10 // 6\nprint(divisao_inteira, 10/6)\n\n1 1.6666666666666667\n\n\n\n1.5.1.1 Ordem de Preced√™ncia\n\n# Parenteses\nexpressao_1 = ((2 + 5) * 3)\nprint(expressao_1)\n\nexpressao_2 = (2 + 5 * 3)\nprint(expressao_2)\n\nexpressao_3 = (1 + 5 ** 2)\nprint(expressao_3)\n\n21\n17\n26\n\n\n\nprint(((2*3)**3)/7)\n\n30.857142857142858\n\n\n\n\n\n1.5.2 Operadores l√≥gicos\nOs operadores l√≥gicos s√£o usados alguma rela√ß√£o entre operandos. Quando utilizados, eles retornam valores booleanos (True ou False).\n\n\n\n\n\n\n\n\n\n1.5.3 Operadores de Atribui√ß√£o\nOs operadores de atribui√ß√£o s√£o usados para atibuir valores a vari√°veis\n\n\n\nnumero = 5\nnumero += 1\nprint(numero)\n\n6\n\n\n\nnumero = 3\nnumero -= 1\nprint(numero)\n\n2\n\n\n\nnumero = 7\nnumero *= 5\nprint(numero)\n\n35\n\n\n\nnumero = 9\nnumero /= 5\nprint(numero)\n\n1.8\n\n\n\nnumero = 5\nnumero %= 2\nprint(numero)\n\n1\n\n\n\n\n\n\n\nüòé",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python I</span>"
    ]
  },
  {
    "objectID": "aula1-python1.html#control-flow",
    "href": "aula1-python1.html#control-flow",
    "title": "1¬† Introdu√ß√£o ao Python I",
    "section": "1.6 Control Flow",
    "text": "1.6 Control Flow\nBasicamente, control flow √© sobre como o programa decide qual parte do c√≥digo executar e quando. Essas ferramentas permitem que o c√≥digo se adapte a diferentes situa√ß√µes, tome decis√µes e realize a√ß√µes repetitivas, dependendo dos valores e condi√ß√µes presentes no programa.\nPara se aprofundar: https://docs.python.org/3/tutorial/controlflow.html\n\n1.6.1 Condicionais\nCondicionais s√£o estruturas usadas para tomar decis√µes dentro de um programa. Elas permitem que o c√≥digo execute diferentes blocos de instru√ß√µes dependendo de condi√ß√µes espec√≠ficas. Assim, com condicionais, √© poss√≠vel direcionar o fluxo do programa com base em crit√©rios, como valores de vari√°veis, facilitando a cria√ß√£o de comportamentos din√¢micos e adaptativos.\n\n1.6.1.1 if\nA estrutura if √© usada para verificar se uma condi√ß√£o √© verdadeira e, caso seja, executar um bloco de c√≥digo espec√≠fico. Ela √© a base das decis√µes em um programa, permitindo que diferentes a√ß√µes aconte√ßamm dependendo do valor de uma condi√ß√£o. Se a condi√ß√£o for verdadeira, o c√≥digo dentro do if ser√° executado; caso contr√°rio, ser√° ignorado.\n\n\n1.6.1.2 if else\nA estrutura if else √© usada quando h√° a necessidade de definir duas a√ß√µes diferentes: uma a ser executada se a condi√ß√£o for verdadeira (if) e outra se essa condi√ß√£o for falsa (else). Dessa forma, ela garante que um dos dois blocos de c√≥digo ser√° executado, cobrindo todas as possibilidades de resultado da condi√ß√£o.\n\n\n1.6.1.3 if elif else\nA estrutura if elif else √© usada quando h√° mais de duas possibilidades para a condi√ß√£o. Primeiro, o if verifica a condi√ß√£o inicial. Caso ela seja falsa, o elif (abrevia√ß√£o de ‚Äúelse if‚Äù) verifica uma nova condi√ß√£o, e isso pode se repetir quantas vezes for necess√°rio. Por fim, o else cobre o caso em que nenhuma das condi√ß√µes anteriores √© satisfeita. Essa estrutura permite criar m√∫ltiplos caminhos de decis√£o dentro do c√≥digo.\n\n\n\n1.6.2 Loops\nLoops s√£o estruturas usadas para repetir um bloco de c√≥digo v√°rias vezes, facilitando a automa√ß√£o de tarefas repetitivas. Eles s√£o √∫teis quando se deseja realizar uma mesma opera√ß√£o v√°rias vezes, seja sobre uma cole√ß√£o de itens ou at√© que uma determinada condi√ß√£o seja atendida. Com loops, √© poss√≠vel escrever um c√≥digo de forma mais concisa e eficiente, evitando a repeti√ß√£o manual de instru√ß√µes.\n\n1.6.2.1 while\nA estrutura while repete um bloco de c√≥digo enquanto uma condi√ß√£o for verdadeira. Ela √© √∫til quando n√£o se sabe exatamente quantas vezes o bloco do c√≥digo precisar√° ser executado, mas sim at√© que uma determinada condi√ß√£o seja atendida. Assim que a condi√ß√£o se tornar falsa, o loop √© interrompido.\n\n\n1.6.2.2 for\nA estrutura for √© usada para repetir um bloco de c√≥digo um n√∫mero espec√≠fico de vezes. Geralmente, √© usada quando j√° se sabe quantas vezes o bloco de c√≥digo deve ser executado. No contexto inicial, sem listas, o for pode ser usado para repetir a√ß√µes com base em um intervalo definido, permitindo automatizar processos repetitivos de maneira simples.\n\n\n\n1.6.3 Keywords\n\n1.6.3.1 break\nA instru√ß√£o break √© usada para interromper um loop antes de ele ser conclu√≠do. Quando o break √© executado, o loop √© finalizado imediatamente, e o programa segue para a pr√≥xima instru√ß√£o. Essa instru√ß√£o √© √∫til quando se deseja parar a repeti√ß√£o ao atender a uma condi√ß√£o espec√≠fica, mesmo que o loop ainda n√£o tenha terminado seu ciclo completo.\n\n\n1.6.3.2 continue\nA instru√ß√£o continue √© usada para pular a itera√ß√£o atual de um loop e avan√ßar para a pr√≥xima itera√ß√£o. Quando continue √© executado, o loop n√£o finaliza, mas simplesmente ignora o restante do bloco de c√≥digo daquela itera√ß√£o e volta para o in√≠cio, verificando a condi√ß√£o novamente ou avan√ßando para o pr√≥ximo item. Isso √© √∫til para evitar executar parte do c√≥digo do loop em condi√ß√µes espec√≠ficas.\n\n\n\n1.6.4 Indo pra pr√°tica‚Ä¶\n\n1.6.4.1 If elif else\n\nhora = 7 \n\nif hora &gt;= 6:\n    print(\"Hora de acordar!\")\nif hora &lt; 6:\n    print(\"Pode dormir mais um pouco.\")\n\nHora de acordar!\n\n\n\ndinheiro = 30\npre√ßo = 25\n\nif dinheiro &gt;= pre√ßo:\n    print(\"Voc√™ pode comprar o produto!\")\nif dinheiro &lt; pre√ßo:\n    print(\"Voc√™ n√£o tem dinheiro suficiente para comprar o produto.\")\n\nVoc√™ pode comprar o produto!\n\n\n\ntemperatura = 80\n\nif temperatura &gt;= 100:\n    print(\"A √°gua est√° fervendo!\")\nif temperatura &lt; 100:\n    print(\"A √°gua n√£o est√° fervendo ainda.\")\n\nA √°gua n√£o est√° fervendo ainda.\n\n\nExemplos que vou mostrar (vou tirar essa se√ß√£o depois, est√° nos coment√°rios)\n\n\n\n\n\n1.6.5 Sintaxe e Defini√ß√£o\n\n\n1.6.6 Argumentos\nArgumentos s√£o valores fornecidos a fun√ß√µes para que elas possam trabalhar com dados espec√≠ficos. Existem tr√™s tipos principais:\n\nArgumentos Posicionais: S√£o passados para a fun√ß√£o na ordem em que s√£o definidos, e essa ordem determina qual par√¢metro ser√° preenchido.\nArgumentos Padr√£o: S√£o valores definidos como padr√£o (default) na fun√ß√£o. Se um valor n√£o for passado ao chamar a fun√ß√£o, o valor padr√£o ser√° usado.\n\n\n\ndef mostrar_dados(idade, nome):\n    print(f\"Nome: {nome}, Idade: {idade}\")\n\n# Posicional\nmostrar_dados(20, \"Aldo\")\n\nNome: Aldo, Idade: 20\n\n\n\ndef funcao_exemplo(fun√ß√£o):\n    fun√ß√£o()\n\ndef dizer_ola():\n    print(\"Ol√°!\")\n\n# Posicional\nfuncao_exemplo(dizer_ola)\n\nOl√°!\n\n\n\ndef saudar(nome, saudacao):\n    print(f\"{saudacao}, {nome}!\")\n\n# Usando argumentos nomeados\nsaudar(nome=\"Vitor\", saudacao=\"Bom dia\")\nsaudar(saudacao=\"Boa tarde\", nome=\"Ana\")  # Aqui a ordem foi invertida, mas podemos identificar os argumentos pelo nome\n\nBom dia, Vitor!\nBoa tarde, Ana!\n\n\n\ndef mostrar_dados_2(nome, idade=30):\n    print(f\"Nome: {nome}, Idade: {idade}\")\n\n# Chamando a fun√ß√£o sem passar o valor para o argumento 'idade', o valor padr√£o ser√° utilizado\nmostrar_dados_2(\"Mariana\")  # Nome: Mariana, Idade: 30\n\n# Chamando a fun√ß√£o passando todos os argumentos\nmostrar_dados_2(\"Jo√£o\", 40)  # Nome: Jo√£o, Idade: 40\n\n# O default deve ser o √∫ltimo par√¢metro a ser definido.\n\nNome: Mariana, Idade: 30\nNome: Jo√£o, Idade: 40\n\n\n\ndef calcular_quadrados(numeros):\n    for numero in numeros:\n        quadrado = numero ** 2\n        print(f\"O quadrado de {numero} √© {quadrado}\")\n\nvalores = [1, 2, 3, 4, 5]\ncalcular_quadrados(valores)\n\nO quadrado de 1 √© 1\nO quadrado de 2 √© 4\nO quadrado de 3 √© 9\nO quadrado de 4 √© 16\nO quadrado de 5 √© 25\n\n\n\n\n1.6.7 Fun√ß√µes An√¥nimas\nFun√ß√µes an√¥nimas s√£o apenas uma forma mais curta de escrever fun√ß√µes normais. Elas tamb√©m s√£o conhecidas como fun√ß√µes lambda. Ao inv√©s de usar def para definir uma fun√ß√£o, as fun√ß√µes an√¥nimas s√£o escritas em uma linha, ideal para tarefas simples. Elas s√£o muito √∫teis quando voc√™ precisa de uma pequena fun√ß√£o que ser√° usada apenas uma vez e n√£o quer se preocupar em dar um nome para ela.\nhttps://www.w3schools.com/python/python_lambda.asp\n\n#Estrutura b√°sica:\n#lambda argumentos: express√£o\n#onde:\n#lambda: A palavra-chave que indica o in√≠cio de uma fun√ß√£o lambda.\n#argumentos: Lista de argumentos separados por v√≠rgulas, semelhante aos argumentos das fun√ß√µes normais. Pode ser um √∫nico argumento, m√∫ltiplos argumentos, ou nenhum.\n#express√£o: Uma express√£o que √© executada e cujo valor √© retornado pela fun√ß√£o lambda. Diferentemente das fun√ß√µes definidas com def, uma fun√ß√£o lambda pode ter apenas uma express√£o.\n\n\n# Fun√ß√£o normal:\n\npreco = int(input('\\nDigite o pre√ßo para o calculo do imposto: '))\n\ndef calcular_imposto(preco):\n    return preco * 0.3\n\nprint(calcular_imposto(preco))\n\n\n# Fun√ß√£o Lambda:\n\npreco = int(input('\\nDigite o pre√ßo para o calculo do imposto: '))\n\ncalcular_imposto = lambda preco: preco * 0.3\n\nprint(calcular_imposto(preco))\n\n\n\n1.6.8 T√©cnicas com Fun√ß√µes\n\n1.6.8.1 Recurs√£o\nDigamos que temos uma s√©rie temporal de vendas di√°rias, e queremos calcular o total acumulado at√© um determinado dia. Uma forma que podemos fazer isso √© montar uma fun√ß√£o recurssiva. De forma simples, n√≥s definimos uma fun√ß√£o que vai se usar novamente dentro de si mesma.\n\ndef acumulado(vendas, n):\n    # Caso base: se o √≠ndice for 0, s√≥ existe um valor a ser somado\n    if n == 0:\n        return vendas[0]\n    # Caso recursivo: soma o valor atual com o acumulado at√© o ponto anterior\n    else:\n        return vendas[n] + acumulado(vendas, n - 1)\n\n# Exemplo de uso\nvendas = [100, 150, 200, 250, 300]\ntotal_acumulado = acumulado(vendas, 4)\nprint(f\"Total acumulado at√© o quinto dia: {total_acumulado}\")\n\nTotal acumulado at√© o quinto dia: 1000\n\n\n\n\n\n1.6.9 Fun√ß√£o como argumento\nJ√° vimos que podemos usar muitas coisas como argumentos para fun√ß√µes, isso incluindo at√© mesmo outras fun√ß√µes. A utilidade disso depende de sua criatividade, mas √© uma ferramenta muito √∫til!\n\ndef aplicar_opera√ß√£o(lista, opera√ß√£o):\n    return [opera√ß√£o(item) for item in lista]\n\n# Fun√ß√µes espec√≠ficas que podemos aplicar\ndef dobrar(x):\n    return x * 2\n\ndef triplicar(x):\n    return x * 3\n\n# Exemplo de uso\nnumeros = [1, 2, 3, 4, 5]\n\nresultado_dobrar = aplicar_opera√ß√£o(numeros, dobrar)\nprint(f\"Dobrando: {resultado_dobrar}\")\n\nresultado_triplicar = aplicar_opera√ß√£o(numeros, triplicar)\nprint(f\"Triplicando: {resultado_triplicar}\")\n\nDobrando: [2, 4, 6, 8, 10]\nTriplicando: [3, 6, 9, 12, 15]",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python I</span>"
    ]
  },
  {
    "objectID": "aula1-python1.html#recapitulando",
    "href": "aula1-python1.html#recapitulando",
    "title": "1¬† Introdu√ß√£o ao Python I",
    "section": "Recapitulando",
    "text": "Recapitulando\nNesta aula, come√ßamos aprendendo a sintaxe b√°sica do Python, que define como organizar o c√≥digo de forma que o Python possa compreend√™-lo. Exploramos conceitos como vari√°veis e tipos de dados, os quais s√£o os ‚Äútijolinhos‚Äù essenciais para armazenar informa√ß√µes e construir um programa.\nEm seguida, discutimos como podemos brincar com esses tijolinhos usando os operadores aritm√©ticos e l√≥gicos. Eles nos permitem manipular esses dados, realizando c√°lculos e criando express√µes l√≥gicas. Entendemos tamb√©m a ordem de preced√™ncia entre esses operadores, que determina a sequ√™ncia em que as opera√ß√µes s√£o executadas.\nDepois, avan√ßamos para o control flow. Aprendemos a tomar decis√µes no c√≥digo usando estruturas condicionais (if, elif, else) e a repetir a√ß√µes automaticamente com os loops (for e while). Tamb√©m vimos como controlar a execu√ß√£o dos loops com break e continue.\nPor fim, abordamos o conceito de fun√ß√µes. Vimos como criar fun√ß√µes utilizando def e como utilizar fun√ß√µes an√¥nimas (lambda). Entendendo como s√£o, essencialmente, o mesmo, mas igualmente importantes.\nEsses conceitos, desde a sintaxe b√°sica at√© a cria√ß√£o de fun√ß√µes e controle de fluxo, formam a base do Python e s√£o fundamentais para que possamos prosseguir e escrever programas organizados.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python I</span>"
    ]
  },
  {
    "objectID": "aula1-python1.html#extras",
    "href": "aula1-python1.html#extras",
    "title": "1¬† Introdu√ß√£o ao Python I",
    "section": "1.7 Extras",
    "text": "1.7 Extras\n\n\n\n1.7.1 Erros/Exce√ß√µes\n\n1.7.1.0.1 Tipos de exce√ß√µes\nRefer√™ncia: https://docs.python.org/3/library/warnings.html, https://www.tutorialsteacher.com/python/error-types-in-python\nExistem v√°rios motivos diferentes para um script n√£o rodar, √© importante saber os mais comuns para ajudar na hora de investigar o que est√° de errado com um c√≥digo.\n\nErro de sintaxe: SyntaxError, IndentationError, TabError\nErro de falta de mem√≥ria: MemoryError, OverflowError\nErro de refer√™ncia: IndexError, KeyError, NameError\nErro de opera√ß√£o: ZeroDivisionError, TypeError\nErro de l√≥gica: o python realiza o c√≥digo, mas n√£o faz o que voc√™ queria que ele fizesse\nExce√ß√µes: ‚Äúo python sabe o que fazer com o c√≥digo mas n√£o consegue realizar a a√ß√£o quista‚Äù\nAvisos: n√£o interrompem o c√≥digo, mas indicam que algo pode estar errado\n\n\n\n1.7.1.0.2 Como lidar com exce√ß√µes?\nRefer√™ncia: https://www.w3schools.com/python/python_try_except.asp\nAvisar ao utilizador do c√≥digo que houve algum erro espec√≠fico:\n\ntry:\n    juros = int(input(\"Qual a taxa de juros desejada? \"))\n    print(\"A taxa escolhida foi {0}%.\".format(juros))\nexcept:\n    print(\"A taxa de juros deve ser um n√∫mero\")\n\nA taxa de juros deve ser um n√∫mero\n\n\nEm um loop, indicar que um dos itens n√£o funcionou, mas realizar a opera√ß√£o para o resto dos itens:\n\nimport requests\n\npaginas = []\nurlList = ['https://finance.yahoo.com/quote/PETR4.SA', 'urlquebrado.com', 'https://finance.yahoo.com/quote/VALE3.SA']\n\nfor url in urlList:\n    try:\n        request = requests.get(url)\n        result = f\"result - {url}\" #algo com os dados da p√°gina\n        paginas.append(result)\n    except:\n        paginas.append(\"NA\")\n        print(f\"A p√°gina {url} n√£o pode ser lida\")\n\npaginas\n\nA p√°gina urlquebrado.com n√£o pode ser lida\n\n\n['result - https://finance.yahoo.com/quote/PETR4.SA',\n 'NA',\n 'result - https://finance.yahoo.com/quote/VALE3.SA']",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python I</span>"
    ]
  },
  {
    "objectID": "aula2-python2.html",
    "href": "aula2-python2.html",
    "title": "2¬† Introdu√ß√£o ao Python II",
    "section": "",
    "text": "Introdu√ß√£o\nEsta aula aborda mais alguns conceitos b√°sicos de python:",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python II</span>"
    ]
  },
  {
    "objectID": "aula2-python2.html#introdu√ß√£o",
    "href": "aula2-python2.html#introdu√ß√£o",
    "title": "2¬† Introdu√ß√£o ao Python II",
    "section": "",
    "text": "OOP: O que √©? E como funciona?\nCole√ß√µes: Quais os tipos?\nVari√°veis: Como aplic√°-las?",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python II</span>"
    ]
  },
  {
    "objectID": "aula2-python2.html#oop-o-que-√©-e-como-funciona",
    "href": "aula2-python2.html#oop-o-que-√©-e-como-funciona",
    "title": "2¬† Introdu√ß√£o ao Python II",
    "section": "2.1 OOP: O que √©? E como funciona?",
    "text": "2.1 OOP: O que √©? E como funciona?\n\nO Objeto como foco de estudo\n\n\n\nCome√ßamos com uma apresenta√ß√£o.\nO objetivo de criar uma fun√ß√£o era dar um nome √† uma opera√ß√£o espec√≠fica, para que n√£o seja necess√°rio escrever essa opera√ß√£o por extenso toda vez que se precise realiz√°-la. Al√©m disso, fica muito mais f√°cil fazer manuten√ß√£o no c√≥digo se existe um erro nessa opera√ß√£o.\nAs classes seguem um objetivo similar, mas servem para dar nome a uma estrutura de dados.\n\n2.1.1 Objetos, Classes e M√©todos\nQuais os elementos da OOP?\n\nObjeto (object) √© uma entidade que possui um comportamento espec√≠fico;\nClasse (class) √© uma estrutura que define as caracter√≠sticas e o comportamento dos objetos;\nAtributos ou Propriedades (Attributes ou Properties): S√£o dados ou estados caracter√≠sticos daquela classe. Por exemplo, ‚Äúpre√ßo m√©dio‚Äù, ‚Äúvolume di√°rio‚Äù e ‚Äúticker‚Äù s√£o propriedades da classe stocks (a√ß√µes);\nM√©todos: S√£o as fun√ß√µes que s√£o espec√≠ficos daquela classe, muitas vezes utilizam os pr√≥prios atributos da classe para realizar uma opera√ß√£o. Por exemplo, pode-se criar um m√©todo na classe ‚Äúa√ß√µes‚Äù que mutliplique o pre√ßo m√©dio pelo volume di√°rio para se obter o volume financeiro m√©dio.\n\n\n\n\n\n2.1.2 Sintaxe e Defini√ß√£o\nPara criar uma classe no python, usamos a palavra class, o nome da classe (com a primeira letra em ma√≠sculo, por conven√ß√£o), e ‚Äú()‚Äù, indicando uma a√ß√£o (no caso, criar um objeto da classe): ‚Äúclass algo()‚Äù\nNormalmente, a defini√ß√£o de uma classe come√ßa pelo m√©todo init. ele √© um m√©todo especial, o m√©todo construtor, e indica que todas as linhas subordinadas a ele devem ser executadas quando um objeto daquela classe √© criado. As linhas que est√£o subordinadas ao m√©todo init s√£o aquelas que estabelecem os atributos.\nAl√©m disso, a palavra self √© uma refer√™ncia a todos os atributos de um objeto. Os m√©todos levam como argumento o pr√≥prio objeto em si, ou seja, o m√©todo que tem self como argumento pode acessar e trabalhar com todos os elementos do objeto em si.\nDepois do m√©todo construtor (init), em geral, v√™m os m√©todos ordin√°rios, aqueles que executam a√ß√µes.\n\n#supondo que queremos calcular a m√©dia das notas 1 e 2 pertencentes a um aluno espec√≠fico\n#aqui criamos uma classe e deixamos em aberto os atributos que o 'aluno' deve ter\nclass aluno():\n  #criando os atributos (nome e notas) da classe aluno\n    def __init__(self, nome, nota1, nota2):\n        self.nome = nome\n        self.nota1 = nota1\n        self.nota2 = nota2\n\n  #criando m√©todos para determinar a m√©dia desse aluno\n    def media(self):\n        return (self.nota1 + self.nota2) / 2\n\n\n#damos um nome e notas para calcular a m√©dia dessa pessoa\nmichel = aluno(nome = \"Michel\", nota1 = 7, nota2 = 10)\n#pedimos para o programa exibir o resultado\nprint(michel.nome, michel.media())\n\nMichel 8.5\n\n\n\n#O que √© o `self` que v√≠amos na defini√ß√£o da classe? √â s√≥ um \"placeholder\" para o nome do objeto. Quando criamos um objeto, com um nome, dessa classe, √© como se os m√©todos virassem:\n\ndef __init__(nome, nota1, nota2):\n  michel.nome = nome\n  michel.nota1 = nota1\n  michel.nota2 = nota2\n\ndef media():\n  return (michel.nota1 + michel.nota2) / 2\n\n\n#Exemplo mais elaborado sobre a√ß√µes\n#determinando as caracter√≠sticas/atributos das a√ß√µes que vamos estudar\nclass Stocks():\n    def __init__(self, ticker_name, price_inDolars, volume_inUnits, beta_float,\n                 divDate_string, enterpriseValue_inDolars, price_inList):\n        self.ticker = ticker_name # preenchendo name com o valor referente ao argumento full_name\n        self.price_last = price_inDolars\n        self.volume_last_day = volume_inUnits\n        self.beta = beta_float\n        self.divDate = divDate_string\n        self.enterpriseValue = enterpriseValue_inDolars\n        self.price_hist = price_inList\n        self.portShare = 0# n√£o vem de argumento, sempre uma a√ß√£o come√ßa com esse valor de argumento\n\n    def eatfinVolume(self): # self entra como argumento para que o procedimento possa acessar os atributos e seus valores.\n        return self.price_last * self.volume_last_day\n\n    def addPrice(self, price):\n        self.price_hist.append(price)\n\n    def changeShare(self, newshare):\n        self.portShare = newshare\n\n#Aqui pedimos para o c√≥digo exibir a a√ß√£o e seus atributos\n\n    def printPrice(self):\n        print(\"The stock \" + self.ticker + \" has a last price of \" + str(self.price_last))\n\n    def __str__(self):\n        return \"The stock \" + str(self.ticker) + \" has a last price of \" + str(self.price_last)\n\n\n#Dando valores e nomes aos atributos\npetr = Stocks(ticker_name = \"PETR4.SA\",\n              price_inDolars = 30.13,\n              volume_inUnits = 93824145,\n              beta_float = 1.33,\n              divDate_string = \"Aug 12, 2022\",\n              enterpriseValue_inDolars = 594060000000,\n              price_inList = [29.80, 30.39, 29.44])\n\n#Exibindo os dados encontrados:\nprint(petr.ticker)\n\npetr.eatfinVolume()\n\npetr.printPrice()\n\npetr.price_last = 31.23\nprint(petr.price_last)\n\npetr.nationality = \"Brazil\"\nprint(petr.nationality)\n\nprint(petr)\n\nPETR4.SA\nThe stock PETR4.SA has a last price of 30.13\n31.23\nBrazil\nThe stock PETR4.SA has a last price of 31.23",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python II</span>"
    ]
  },
  {
    "objectID": "aula2-python2.html#cole√ß√µes-quais-os-tipos",
    "href": "aula2-python2.html#cole√ß√µes-quais-os-tipos",
    "title": "2¬† Introdu√ß√£o ao Python II",
    "section": "2.2 Cole√ß√µes: Quais os tipos?",
    "text": "2.2 Cole√ß√µes: Quais os tipos?\n\nTransformando v√°rios itens em uma vari√°vel \n\n\n\nQuais os tipos de cole√ß√µes?\n\nListas\nTuplas\nSets\nDicion√°rios\n\nO nome cole√ß√µes vem de ‚Äúconjunto‚Äù de dados, e existem quatro tipos diferentes, que servem para objetivos diferentes, baseados em suas caracter√≠sticas:\n\n\n\n\nOrdenado\nMut√°vel\nDuplicatas\n\n\n\n\nListas\nsim\nsim\nsim\n\n\nTuples\nsim\nn√£o\nsim\n\n\nSets\nn√£o\nn√£o\nn√£o\n\n\nDicion√°rios\nsim\nsim\nn√£o\n\n\n\nEm termos mais simples listas s√£o as mais flex√≠veis e menos espec√≠ficas, tuples s√£o listas imut√°veis, e dicion√°rios s√£o listas nomeadas. Sets, os mais restritivos, funcionam como o conceito de ‚Äúconjunto‚Äù da matem√°tica.\nCada cole√ß√£o tem seus pr√≥prios m√©todos, d√™em uma olhada neles nos tutoriais abaixo:\n\nW3Schools: https://www.w3schools.com/python/python_lists.asp (mais simples e sucinto);\nDocumenta√ß√£o do Python: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences (mais t√©cnico, mais informa√ß√µes).\n\n\n2.2.1 Listas\nS√£o estruturas de dados que servem para transformar um grupo de itens em uma s√≥ vari√°vel.\n\n2.2.1.1 Sintaxe e Defini√ß√£o\n\nPodemos criar uma lista de duas formas: definindo-a diretamente por meio de ‚Äúnome_qualquer_da_lista = [item1, item2, ‚Ä¶, itemx]‚Äù, s√≥ colocando os itens dentro dos colchetes; ou tamb√©m podemos transformar outros iter√°veis (como bibliotecas e tuplas, que veremos mais tarde) em listas com ‚Äúnome_qualquer_da_nova_lista = list(nome_do_iter√°vel)‚Äù. Simplificando: list = [ ] ou list( )\nPara saber qual o tipo/ classe de algum objeto no c√≥digo, utilizamos ‚Äútype(nome_do_objeto)‚Äù. Por exemplo, ao escrever ‚Äúprint(type(objeto))‚Äù, sendo objeto uma lista, devemos ter como retorno: ‚Äú&lt;class ‚Äòlist‚Äô&gt;‚Äù\n\n\n\n2.2.1.2 Acessar e Alterar\n\nT√©cnicas de indexing [] e [:]\n\n\nPodemos acessar itens espec√≠ficos das listas atribuindo-lhes n√∫meros, de acordo com a ordem que aparecem na lista usando [n√∫mero]. Por exemplo, em lista = [Jo√£o, Pedro, Carlos] podemos selecionar o objeto Jo√£o e exib√≠-lo com print(lista[0]). Seguindo essa l√≥gica, Pedro representa o elemento 1 e Carlos o elemento 2.\nTamb√©m podemos acessar intervalos dentro das listas com [n√∫mero1:n√∫mero2]. Exemplo: em lista = [a,b,c,d,e], podemos acessar e exibir as letras de ‚Äúa‚Äù a ‚Äúd‚Äù com print(lista[0:3])\n\n\nNested lists\n\n\n√â quando temos listas com outras sublistas dentro delas como objetos. lista = [[a,b,c], [1,2,3], [x,y,z]]\nAcessamos as sublistas assim como fazemos para objetos numa lista normal, mas para acessar objetos de dentro das sublistas utilizamos outro m√©todo. Ex: para exibir a letra ‚Äúb‚Äù da primeira sublista no exemplo anterior, temos print(lista[0][1]). Em resumo, apenas adicionamos o n√∫mero referente ao elemento que queremos acessar da sublista ao lado do n√∫mero que representa a sublista.\n\n\n\n2.2.1.3 Adicionar, Unir, e Remover\n\nPara adicionar elementos a uma lista ou unir v√°rias listas, temos diferentes m√©todos:\n\n\nm√©todo APPEND: escrevemos ‚Äúlista.append(item)‚Äù para adicionar um item ao final da lista. ex: lista = [1,2] ‚Äì&gt; lista.append(3) ‚Äì&gt; lista = [1,2,3]\nm√©todo INSERT: escrevemos ‚Äúlista.insert(posi√ß√£o, item)‚Äù para adicionar um item em uma posi√ß√£o espec√≠fica. ex: lista = [a,b,c] ‚Äì&gt; lista.insert(1, x) ‚Äì&gt; lista = [a,x,b,c] elemento x adicionado na posi√ß√£o 1.\nm√©todo EXTEND: escrevemos ‚Äúlista1.extend(lista2)‚Äù para adicionar os elementos da lista2 na lista1. ex: lista1 = [1,2] e lista2 = [3,4] ‚Äì&gt; lista1.extend(lista2) ‚Äì&gt; lista1 = [1,2,3,4]\nm√©todo ‚Äú+‚Äù: escrevemos ‚Äúlista3 = lista1 + lista2‚Äù para criar uma nova lista com os elementos de outras listas. ex: lista1 = [1,2] e lista2 = [3,4] ‚Äì&gt; lista3 = lista1 + lista2 ‚Äì&gt; lista3 = [1,2,3,4]\n\n\nPara remover itens das listas:\n\n\nm√©todo CLEAR: escrevemos list.clear() pra remover todos os elementos da lista, deixando-a vazia.\nm√©todo POP: escrevemos list.pop(n√∫mero_do_item) para remover um item da lista chamando-o pelo seu n√∫mero ou index dentro da lista.\nm√©todo REMOVE: escrevemos list.remove(item) para remover um item da lista chamando-o pelo nome.\nm√©todo DEL: escrevemos del list[n√∫mero_do_item] para remover um item da lista pelo seu index, assim como em pop, por√©m podemos tamb√©m remover um itervalo utilizando del list[index1:index2].\n\n\n\n2.2.1.4 Tamanho, Ordem, e Posi√ß√£o\n\nfun√ß√£o LENGTH: utilizamos len(lista) para saber quantos itens h√° dentro de uma lista. ex: print(len(lista)) ‚Äì&gt; retorno: n√∫mero de itens da lista\nfun√ß√£o SORT: utilizamos lista.sort() para reorganizar uma lista com n√∫meros em ordem crescente\nfun√ß√£o REVERSE: utilizamos lista.reverse() com o mesmo objetivo de sort, mas em ordem decrescente\nfun√ß√£o INDEX: utilizamos lista.index(item) para descobrir o index/ n√∫mero na lista do item\nfun√ß√£o COUNT: utilizamos lista.count(item) para descobrir quantas vezes o mesmo item aparece dentro de uma lista.\nOBSERVA√á√ÉO: lembre-se que para exigir um retorno/ uma resposta do programa √© necess√°rio escrever print, assim como no exemplo dado na fun√ß√£o length, se n√£o o c√≥digo vai apenas fazer altera√ß√µes sem exibir nada!\n\n\n\n2.2.1.5 Comparadores\n\nOPERADOR ‚Äú==‚Äù e ‚Äú!=‚Äù: ‚Äú==‚Äù verifica se duas listas s√£o iguais, tem elementos e quantidades similares. ‚Äú!=‚Äù √© o contr√°rio, verifica se listas s√£o diferentes. Ex: lista1 = [1,2] e lista2 = [1,2] e lista3 = [3,4] ‚Äì&gt; print(lista1 == lista2) e print(lista2 == lista3) ‚Äì&gt; retornos: True e False\nOPERADOR ‚Äú&gt;‚Äù, ‚Äú&gt;=‚Äù, ‚Äú&lt;‚Äù e ‚Äú&lt;=‚Äù: verificam se as listas com n√∫meros s√£o menores, maiores ou iguais. Elas comparam elemento por elemento na ordem que aparecem e n√£o o total, se uma delas tiver mais elementos e tiver elementos iguais a outra, a com mais elementos ser√° considerada a maior. Ex: lista1 = [1,2,4], lista2 = [1,3,2] e lista3 = [1,2,4,5] ‚Äì&gt; print(lista1 &gt; lista2) e print(lista1 &lt; lista3) ‚Äì&gt; retornos: False e True\nOPERADOR ‚ÄúIS‚Äù e ‚ÄúIS NOT‚Äù: verificam se as listas se referem ao mesmo objeto na mem√≥ria ou n√£o. √â complicado e n√£o √© a mesma coisa que ‚Äú==‚Äù e ‚Äú!=‚Äù. Listas com os mesmos elementos n√£o s√£o necessariamente a mesma coisa. EX: lista1 = [1,2] e lista2 = lista1 e lista3 = [1,2] ‚Äì&gt; print(lista1 is lista2) e print(lista1 is lista3) ‚Äì&gt; retornos: True e False\nOPERADOR ‚ÄúIN‚Äù e ‚ÄúNOT IN‚Äù: verificam se um item est√° ou n√£o em uma lista. N√£o √© poss√≠vel comparar listas com elementos de dentro de outra listas, a menos que a lista seja literalmente uma objeto ou sublista de dentro da outra lista. (meio confuso, mas vc vai entender, confia) ex: lista1 = [1,2] e lista2 = [1] ‚Äì&gt; print(1 in lista1) e print(lista2 in lista1) ‚Äì&gt; retornos: True e False\n\n\n\n2.2.1.6 Loops e Comprehension\n\nLoops: fun√ß√µes que criam uma repeti√ß√£o de outros c√≥digos\n\n\nFOR: utilizamos ‚Äúfor‚Äù para iterar (gerar uma repeti√ß√£o) sobre elementos de uma lista. ex: lista = [1, 2, 3, 4] ‚Äì&gt; for item in minha_lista: print(item) ‚Äì&gt; retorno: 1, 2, 3, 4. Neste exemplo, o for vai fazer o c√≥digo repetir o print para cada uma dos itens de dentro da lista.\nWHILE: utilizamos ‚Äúwhile‚Äù para repetir o c√≥digo enquanto uma condi√ß√£o espec√≠fica for verdadeira. ex: contador = 0 ‚Äì&gt; while contador &lt; 5: print(contador) contador += 1 ‚Äì&gt; retorno: 0, 1, 2, 3, 4\nBREAK: utilizamos ‚Äúbreak‚Äù para quebrar um loop\nCONTINUE: utilizamos ‚Äúcontinue‚Äù para pular para outra itera√ß√£o do c√≥digo\n\n\nComprehension: Cria√ß√£o de listas a partir de fun√ß√µes curtas, geralmente com uso de for\n\n\nFOR: (de novo ele?) utilizamos o for para que uma fun√ß√£o se repita e forme os elementos de uma nova lista\nIF: utilizamos if para estabelecer uma condi√ß√£o que deve ser atendida para que o c√≥digo rode\n\n\n\n2.2.1.7 Alguns exemplos:\n\n#Exemplo: Criado listas a partir de []\nlista = [1, 2, 5] # definindo a lista com os itens \"1\", \"2\" e \"5\"\nprint(lista) #Exibindo a lista\nprint(type(lista)) #Exibindo o tipo/ a classe do objeto criado, no caso uma lista\n\n[1, 2, 5]\n&lt;class 'list'&gt;\n\n\n\n#Exemplo: Criando listas a partir de list()\ntext = 'Python' #Texto como objeto que servir√° de exemplo\ntext_list = list(text) #Transformando o texto em uma lista\nprint(text_list) #Exibindo a nova lista criada\nprint(type(text_list)) #Exbindo o tipo/ a classe do objeto criado, no caso uma lista\n\n['P', 'y', 't', 'h', 'o', 'n']\n&lt;class 'list'&gt;\n\n\n\n#Exemplo: Uso de BREAK e CONTINUE\nfor i in range(5): # Gera n√∫meros at√© ou menores que 5\n    if i == 3:\n        break  # Sai do loop quando i for igual a 3\n    print(i)\n# Output: 0 1 2\n\nfor i in range(5):\n    if i == 2:\n        continue  # Pula o valor 2 e continua\n    print(i)\n# Output: 0 1 3 4\n\n0\n1\n2\n0\n1\n3\n4\n\n\n\n#Exemplo de Comprehension List bem simples\nquadrados = [] # Criando lista vazia\nfor x in range(1, 6): # Elementos ser√£o os n√∫meros entre 1 at√© 6\n    quadrados.append(x**2) # Elevamos os itens dentro da lista ao quadrado\nprint(quadrados) # Exibindo o resultado\n\n[1, 4, 9, 16, 25]\n\n\n\n\n\n2.2.2 Tuples\nSemelhantes √†s listas, por√©m s√£o imut√°veis: n√£o √© poss√≠vel alterar seus itens umas vez criadas.\n\n2.2.2.1 Sintaxe e Defini√ß√£o\n\nPara criar uma tupla, escrevemos ‚Äúnome_da_tupla = (itens)‚Äù, igual √†s listas, mas substituindo as chaves por par√™nteses.\nPodemos usar ‚Äútype()‚Äù para identificar uma tupla no c√≥digo, que vai retornar ‚Äú&lt;class ‚Äòtuple‚Äô&gt;‚Äù #### Similaridades com Listas\nComo tuplas s√£o imut√°veis, n√£o √© poss√≠vel utilizar as mesmas fun√ß√µes que utilizamos para modificar a ordem ou os itens das listas. Contudo, n√≥s podemos gerar uma tupla atrav√©s de uma lista, ou transformar uma tupla em lista para criar outra tupla modificada em cima disso.\nN√£o existe Tuple Comprehension direta como no caso das listas. Para criar fazer uma comprehension usamos a sintaxe ‚Äútupla = tuple(insert_formulinhas_m√°gicas_here)‚Äù\n\n\n\n2.2.2.2 Unpacking\n\n√â uma t√©cnica na qual atribu√≠mos uma vari√°vel a cada item de dentro da tupla, como se fossem coordenadas. Para fazer isso, basta chamar a lista criada e dar nomes √†s vari√°veis. ex: tupla = (1,2,3) ‚Äì&gt; tupla = a, b, c ‚Äì&gt; a= 1; b=2; c = 3.\n\n\n# Exemplo de modifica√ß√£o de tuplas\n# Tupla original\nminha_tupla = (1, 2, 3, 4)\n\n# Convertendo a tupla para uma lista\nminha_lista = list(minha_tupla)\n\n# Modificando a lista\nminha_lista.append(5)\n\n# Transformando em Tupla novamente\nminha_tupla2 = tuple(minha_lista)\n\n# Mostrando o resultado\nprint(minha_tupla2)\n\n(1, 2, 3, 4, 5)\n\n\n\n# Exemplo unpacking\n# Tupla com tr√™s elementos\nminha_tupla = (10, 20, 30)\n\n# Unpacking: cada elemento da tupla √© atribu√≠do a uma vari√°vel\np√£o, de, batata = minha_tupla\n\n# Exibindo os valores atribu√≠dos\nprint(p√£o)\nprint(de)\nprint(batata)\n\n10\n20\n30\n\n\n\n\n\n2.2.3 Dicts\nDicion√°rios s√£o estruturas de dados que tamb√©m armazenam itens dentro de si, mas que s√£o acess√°veis por chaves.\n\n2.2.3.1 Sintaxe e Defini√ß√£o\n\nPara criar uma biblioteca usamos ‚Äúdicion√°rio = {chaves:itens}‚Äù ou ‚Äúdicion√°rio = dict(chaves:itens)‚Äù. H√° tamb√©m a sintaxe ‚Äú.fromkeys‚Äù, que associa uma sequ√™ncia de chaves a um valor dado.\nNeste caso, ‚Äútype()‚Äù retornar√° ‚Äú&lt;class ‚Äòdict‚Äô&gt;‚Äù\n\n\n\n2.2.3.2 Similaridades com Listas\nAlgumas operacoes que sao validas tanto para listas quanto para bibliotecas: * Para remover itens de dicts, podemos usar os metodos .pop, del e clear(), extamente como nas listas, mas utilizando as chaves para se referir aos elementos. * Tambem e possivel fazer dicts comprehension. Escrevemos: dicionario = {expressao_que_gera_valores_para_as_chaves}\n\n\n2.2.3.3 Acessar e Alterar\n\nTecnicas de indexing:\n\n\n.KEYS: podemos escrever nome_biblioteca.keys() para acessar todas as suas chaves.\n.VALUES: de forma contr√°ria, se quisermos acessar os valores aos quais as chaves se referem, escrevemos nome_biblioteca.values()\n.ITENS: retorna todos os pares de valores e chaves: nome_biblioteca.itens()\n.GET: retorna o valor de uma chave espec√≠fica e retorna ‚Äúnone‚Äù se a chave n√£o existir: nome_biblioteca.get(chave)\n\n\nAlterando os valores das bibliotecas:\n\n\n.UPDATE: adiciona chaves e atualiza valores de chaves que j√° existiam, como se fosse uma sobreposi√ß√£o de bibliotecas. biblioteca_original.update(biblioteca_nova)\n.POP: assim como nas listas, escrevemos nome_biblioteca.pop(chave) para retirar um dos elementos da biblioteca e retornar o seu valor.\n.POPITEM: retira o √∫ltimo par chave-valor na ordem da lista e retorna esse mesmo par. Sua sintaxe √© nome_biblioteca.popitem()\n.SETDEFAULT: podemos escrever nome_biblioteca.setdefault(chave, valor) para adicionar uma nova chave e valor √† biblioteca. Se a chave j√° existir, retorna apenas o valor original associado √† ela, independente do valor que foi escrito no setdefaut.\n\n\n#Exemplo de dicts comprehension:\nquadrados = {x: x**2 for x in range(5)}\nprint(quadrados)\nprint(quadrados.keys())\n\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\ndict_keys([0, 1, 2, 3, 4])\n\n\n\n\n\n2.2.4 Sets\n√â uma estrutura que carrega dados √∫nicos (n√£o se repetem) e desordenados (n√£o podem ser acessados por √≠ndice como nas listas). √â poss√≠vel modific√°-la e √© √∫til quando precisamos de itens n√£o repetentes e a ordem desses elementos √© irrelevante. Sua sintaxe √© ‚Äúnome_set = {itens}‚Äù.\n\n2.2.4.1 Sintaxe e Defini√ß√£o\n\nPara criar um set, podemos transformar outras cole√ß√µes ou estruturas (como strings (textos), tuplas, listas, etc) para criar um novo set por meio de novo_set = set(nome_da_lista/string/tupla).\ntype() retornar√° &lt;class ‚Äòset‚Äô&gt;\n\n\n\n2.2.4.2 Similaridades com Listas\n\nAssim como nas listas, podemos usar comprehension, unir, ver interse√ß√µes e diferen√ßas entre os sets.\nA sintaxe para criar sets a partir de fun√ß√µes (comprehension) √©: set = {express√£o for item in iter√°vel}\n\n\n\n2.2.4.3 Acessar e Alterar\n\n.ADD: escrevemos nome_set.add(item) para adicionar um item ao set.\n.DISCARD: escrevemos nome_set.discard(item) para remover um item do set\n\n\n\n2.2.4.4 Set Operations\n\n.UNION ou (|): h√° dois modos de unir dois sets em um novo set, podemos escrever ‚Äúset3 = set1.union(set2)‚Äù ou ‚Äúset3 = set1 | set2‚Äù\n.INTERSECCTION ou (&): para retornar um set com os elementos comuns entre dois outros sets, escrevemos ‚Äúset1.intersection(set2)‚Äù ou ‚Äúset1 & set2‚Äù\n.UPDATE ou (|=): adiciona os elementos de um set a outro, modificando o set original. ‚Äúset1.update(set2)‚Äù ou set1 |= set2\n.ISSUBSET ou (&lt;) ou (&lt;=): verifica (retorna True ou False) se todos elementos est√£o contidos em outro subset. ‚Äúset1.issubset(set2)‚Äù ou ‚Äúset1 &lt;= set2‚Äù, se retorno for True, ent√£o set1 √© subconjunto de set2.\n.ISSUPERSET ou (&gt;) ou (&gt;=): faz o contr√°rio do issubset, verifica se todos os elementos de outro set est√£o contidos no set analizado. ‚Äúset1.issuperset(set2)‚Äù ou ‚Äúset1 &gt;= set2‚Äù, se retorno for True, ent√£o set1 √© superconjunto de set2.\n.ISDISJOINT: verifica se dois sets n√£o t√™m elementos comuns. ‚Äúset1 = {1, 2, 3}‚Äù, ‚Äúset2 = {4, 5, 6}‚Äù ‚Äì&gt; ‚Äúprint(set1.isdisjoint(set2))‚Äù ‚Äì&gt; retorno: ‚ÄúTrue‚Äù (n√£o t√™m elementos em comum)\n.DIFFERENCE ou (-): retorna um novo set dos elementos que est√£o em um set mas n√£o na outro. ‚Äúset1.difference(set2)‚Äù ou ‚Äúset1 - set2‚Äù\n.SYMMETRIC_DIFFERENCE ou (^): retorna um novo set contendo os elementos que est√£o em apenas uma dos sets ‚Äúset1.symmetric_difference(set2)‚Äù ou ‚Äúset1 ^ set2‚Äù\n\n\n\n\n\n\nüòé\n\n\n\n\n\n\n2.2.5 Fun√ß√µes Sobre Iter√°veis\n\n\n\nmy_list = ['S√£o Paulo', 'Flamengo']\n\nenumerate(my_list), list(enumerate(my_list))\n#type(enumerate(my_list))\n\n(&lt;enumerate at 0x7e7ff6f7fec0&gt;, [(0, 'S√£o Paulo'), (1, 'Flamengo')])\n\n\n\n#sem enumerate:\nindex = 0\nfor i in my_list:\n    print('Parab√©ns ' + i + '! Voc√™ ficou em ' + str(index + 1) + '¬∫ lugar!')\n    index += 1\n\nParab√©ns S√£o Paulo! Voc√™ ficou em 1¬∫ lugar!\nParab√©ns Flamengo! Voc√™ ficou em 2¬∫ lugar!\n\n\n\n#com enumerate:\nfor index, i in enumerate(my_list):\n    print('Parab√©ns ' + i + '! Voc√™ ficou em ' + str(index + 1) + '¬∫ lugar!')\n\nprint(\"cof cof Copa do Brasil cof cof\")\n\nParab√©ns S√£o Paulo! Voc√™ ficou em 1¬∫ lugar!\nParab√©ns Flamengo! Voc√™ ficou em 2¬∫ lugar!\ncof cof Copa do Brasil cof cof\n\n\n\ndef maior_que_dois(x):\n    return x &gt; 2\n#Ou utilizar uma fun√ß√£o an√¥nima \"lambda\": lambda x: x &gt; 2\n\nmy_list = [1,2,3,4]\nprint(list(filter(maior_que_dois, my_list)))\nprint(list(filter(lambda x: x&gt;2, my_list)))\n\n[3, 4]\n[3, 4]\n\n\n\nmy_map = list(map(maior_que_dois, my_list)) # map: aplicar uma fun√ß√£o para todos os itens\nmy_map\n\n[False, False, True, True]\n\n\n\nprint(my_list)\nprint(my_map)\n[my_list, my_map]\n\n[(my_list[i], my_map[i]) for i in range(4)]\nlist(zip(my_list, my_map))\n# zip(): une tuplas, mas √© um objeto pr√≥prio\n# ‚Üí precisa fazer tuple(zip()) para ver a tupla mesmo\n\n[1, 2, 3, 4]\n[False, False, True, True]\n\n\n[(1, False), (2, False), (3, True), (4, True)]",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python II</span>"
    ]
  },
  {
    "objectID": "aula2-python2.html#vari√°veis-como-aplic√°-las",
    "href": "aula2-python2.html#vari√°veis-como-aplic√°-las",
    "title": "2¬† Introdu√ß√£o ao Python II",
    "section": "2.3 Vari√°veis: Como aplic√°-las?",
    "text": "2.3 Vari√°veis: Como aplic√°-las?\n\n\n\nFalamos sobre como vari√°veis s√£o um conjunto nome-valor. Vamos explorar um pouco mais essa ideia.\nRefer√™ncia: https://nedbatchelder.com/text/names.html (fonte dos diagramas).\nObs: a discuss√£o aqui introduz um conceito te√≥rico, do mundo da Ci√™ncia da Computa√ß√£o. Al√©m de ser algo interessante, que vai ajudar voc√™ a entenderem como linguagens de programa√ß√£o funcionam, vai ajudar na pr√°tica a evitar um tipo espec√≠fico de erro.\nConsidere o c√≥digo x = 23, n√≥s temos o nome ‚Äúx‚Äù fazendo refer√™ncia ao valor (na mem√≥ria do computador) ‚Äú23‚Äù:\n\n\nx refers to 23\n\nx23\n\nSe fizermos y = x, n√£o criamos um novo objeto, mas temos agora um novo nome apontando para o mesmo valor:\n\n\nx and y both refer to 23\n\nxy23\n\nNote que poderia ser o contr√°rio, na cria√ß√£o de y, criava-se um novo valor (local na mem√≥ria) para ele, como abaixo, mas n√£o √©.\n\n\nx and y aren‚Äôt magically linked\n\nxy2323\n\nE se alterarmos a vari√°vel y, o que pode acontecer?\n\nO valor (o √∫nico que existe) √© alterado, e os dois nomes agora fazem refer√™ncia a esse valor atualizado.\nCria-se um novo valor para y, e agora cada nome se refere a um valor diferente.\n\nNo Python, neste caso, o que acontece √© a segunda op√ß√£o.\nSe rodarmos y = 12, o que n√£o acontece √©:\n\n\nx and y both refer to 23\n\nxy12\n\nE sim:\n\n\nx and y aren‚Äôt magically linked\n\nxy1223\n\nIsso √©, o valor foi primeiro copiado (para um novo local da mem√≥ria), e depois alterado. Esse comportamento tem o nome de ‚Äúcopy-on-modify‚Äù.\nEm oposi√ß√£o:\n\nPoder√≠amos chamar o comportamento em vermelho de ‚Äúcopy-on-creation‚Äù.\nO comportamento da ‚Äúop√ß√£o 2.‚Äù √© chamado de ‚Äúmodify in place‚Äù.\n\nMas esse comportamento depende do tipo do objeto. No exemplo acima, o valor foi copiado, porque era imut√°vel. Alguns tipos de valores s√£o mut√°veis e s√£o ‚Äúmodified-in-place‚Äù.\nVoc√™s viram que listas s√£o mut√°veis, vamos ver um exemplo com elas.\nO c√≥digo:\nnums = [1, 2, 3]\ntri = nums\nGera:\n\n\nnums and tri both refer to the same list\n\nnumstri123\n\nE se rodarmos nums.append(4)? Listas s√£o mut√°veis, ent√£o n√£o criaremos uma c√≥pia/um novo valor para nums, e sim, modificaremos o valor a quem nums se refere, in-place:\n\n\nchanging the list means both names see the change\n\nnumstri1234\n\nEssa diferen√ßa de comportamento, a depender do tipo do objeto, gera muita confus√£o. Para usu√°rios de R, notem que no R, todos (menos um) os tipos de objetos s√£o imut√°veis, e s√£o copied-when-modified, no Python, isso n√£o √© verdade.\nDo artigo do Ned Batchelder:\n\nThis Mutable Presto-Chango is the biggest issue people have with Python‚Äôs names and values. A value is shared by more than one name, and is modified, and all names see the change.\n\n\nKeep in mind, this is not a bug in Python, however much you might wish that it worked differently. Many values have more than one name at certain points in your program, and it‚Äôs perfectly fine to mutate values and have all the names see the change. The alternative would be for assignment to copy values, and that would make your programs unbearably slow.\n\nAgora, voc√™s sabem o mecanismo por tr√°s desse comportamento, e podem evitar cometer erros em rela√ß√£o √† isso.\nQuando voc√™s v√£o criar um objeto mut√°vel com base em outro, deve-se perguntar: ‚Äúeu quero que esse nome tenha a sua pr√≥pria c√≥pia independente dos dados, ou quero que ambos os nomes fa√ßam refer√™ncia ao mesmo dado?‚Äù.\n\nSe a sua inten√ß√£o √© a segunda, fa√ßa y = x.\nSe √© a segunda, os objetos mut√°veis tem um m√©todo .copy() exatamente para isso, faca y = x.copy()",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python II</span>"
    ]
  },
  {
    "objectID": "aula2-python2.html#recapitulando",
    "href": "aula2-python2.html#recapitulando",
    "title": "2¬† Introdu√ß√£o ao Python II",
    "section": "2.4 Recapitulando!",
    "text": "2.4 Recapitulando!\n\nConceitos importantes de OOP\n\n\nClasse: Estrutura dos objetos\nObjeto: A base de tudo\nEncapsulamento: Os dados e opera√ß√µes s√£o protegidos, √© necess√°rio conhecimento pr√©vio para interagir com uma classe\nHeran√ßa: Uma classe (subclasse) pode reutilizar c√≥digos de outras classes (superclasses)\nPoliformismo: Classes podem adotar m√©todos com o mesmo nome, mas que geram comportamentos diferentes\nAbstra√ß√£o: Os dados e opera√ß√µes s√£o parcialmente ocultos, para simplificar o uso\n\n\nTipos de cole√ß√µes (estruturas de dados)\n\n\nListas: ordenada, mut√°vel, ‚Äú[]‚Äù\nTuplas: ordenada, imut√°vel,‚Äú()‚Äù\nDicts: ordenada, mut√°vel, acesso dos itens por meio de chaves, ‚Äú{}‚Äù\nSets: desordenada, mut√°vel, ‚Äú{}‚Äù\n\n\nVari√°veis\n\n\nVari√°vel = nome associado a um valor, pense nisso como numa equa√ß√£o matem√°tica ‚Äúf(x)‚Äù em que podemos atribuir valores quaisquer a x, que seria o nome da vari√°vel, a fim de encontrar um resultado y.\nN√≥s podemos mudar os valores das vari√°veis ap√≥s a defini√ß√£o de uma vari√°vel, no nosso exemplo, podemos no mesmo c√≥digo escrever que x vale 1 e depois mudar para x = 2, por exemplo.\nEm python, vari√°veis s√£o mut√°veis!",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python II</span>"
    ]
  },
  {
    "objectID": "aula2-python2.html#extras",
    "href": "aula2-python2.html#extras",
    "title": "2¬† Introdu√ß√£o ao Python II",
    "section": "2.5 Extras",
    "text": "2.5 Extras\n\n\n\n2.5.1 f-strings\n√â uma forma simples de estruturar uma string (texto) dentro do python. Isso permite personalizar mensagens de forma r√°pida.\n\n#Exemplo de f-string\n\nnome = 'Maria'\nidade = 30\n\n# Usando f-string para formar a mensagem\nmensagem = f'{nome} tem {idade} anos.'\nprint(mensagem)\n\n\n\n2.5.2 Fun√ß√µes √öteis\n\nDaqui em diante, a aula √© 100% expositiva. Vamos explicar as fun√ß√µes mais essenciais, e o resto fica aqui de consulta para voc√™s.\nRefer√™ncia: https://docs.python.org/3/library/functions.html\n\n2.5.2.1 Fun√ß√µes relacionadas √† tipos de vari√°veis\n\n# O que √©: bool √© a classe \"bin√°ria\", ou seja, fala se o valor, no output, √© \"certo\" ou \"errado\". Se o argumento (o que est√° escrito entre par√™nteses) conter um zero, nenhum n√∫mero, ou n√£o √© o que estamos procurando, este processo retornar√° com um \"false\". Caso contr√°rio, o output ser√° \"true\".\n\n# Para que serve: essa classe √© na verdade uma subclasse da classe \"int\" (classe apresentada na se√ß√£o \"Fun√ß√µes relacionadas √† tipos de vari√°veis\"). Ela √© usada para decobrirmos se um argumento √© verdadeiro/falso.\n\nbool(0), bool(1), bool(1811275162543)\n\n(False, True, True)\n\n\n\n# O que √©: float() √© a classe que transforma um n√∫mero escrito sem ponto ou como uma mistura de letras e n√∫meros em um n√∫mero com n√∫mero decimais.\n\n# Para que serve: essa classe √© na verdade uma subclasse da classe \"int\" (classe apresentada na se√ß√£o \"Fun√ß√µes relacionadas √† tipos de vari√°veis\"). Ela √© usada para conseguirmos trabalhar com n√∫meros mais precisos e menores, sem zeros demais, por exemplo.\n\nfloat(10), float(3.5), float('3.5')\n\n(10.0, 3.5, 3.5)\n\n\n\n# O que √©: int() √© a classe que transforma um n√∫mero escrito com n√∫mero decimais ou como uma mistura de letras e n√∫meros em um n√∫mero sem n√∫mero decimais e arrendodado. Quando n√£o colocamos n√∫mero, o output √© zero.\n\n# Para que serve: essa classe √© usada para podermos trabalhar com n√∫meros sem decimais, e tamb√©m para ajudar a evitar bugs ao rodar o c√≥digo com n√∫meros com muitas casas decimais.\n\nint('8'), int(10.7)\n\n'8'\n\n\n\n# O que √©: str() √© a classe que transforma em string o que est√° em par√™nteses, independente do que seja.\n\n# Para que serve: essa classe √© usada para os bytes, como tudo est√° escrito nos par√™nteses, por padr√£o, serem convertidos em string. Esse m√©todo funciona sem que os argumentos sejam codificados ou seja, os eventuais erros de codifica√ß√£o n√£o s√£o apresentados.\n\nstr(8)\n\n'8'\n\n\n\n# O que √©: type() √© a classe que identifica o que est√° escrito entre par√™nteses.\n\n# Para que serve: essa classe √© usada para identificar qualquer tipo de m√≥dulo padr√£o, que s√£o os tipos incorporados por padr√£o (s√£o todos os m√≥dulos vistos at√© aqui at√© o final da se√ß√£o \"Outras fun√ß√µes\").\n\ntype([1, 2])\n\nlist\n\n\n\n\n2.5.2.2 Fun√ß√µes sobre cria√ß√£o de vari√°veis\n\n# O que √©: dict() √© a classe que cria um \"dicion√°rio\" entre palavras e n√∫meros (sejam eles com decimais, ou n√£o).\n\n# Para que serve:\na = dict(one=1, two=2, three=3.2)\nb = {'one': 1, 'two': 2, 'three': 3.2}\nc = dict(zip(['one', 'two', 'three'], [1, 2, 3.2]))\na == b == c\n\n{1: False, 2: False, 3: True, 4: True}\n\n\n\nlist()\n\n[]\n\n\n\nset([1,2,2,3,4])\n\n{1, 2, 3, 4}\n\n\n\ntuple(my_list)\n\n(1, 2, 3, 4)\n\n\n\ntype((1, 2))\n\ntuple\n\n\n\n\n2.5.2.3 Outras fun√ß√µes\n\nmy_list, repr(my_list), eval(repr(my_list)), eval('1+2')\n# eval(): avalia um string para ver se tem como fazer contas l√° dentro ‚Üí se der, devolve quanto que d√°\n\n([1, 2, 3, 4], '[1, 2, 3, 4]', [1, 2, 3, 4], 3)\n\n\n\ninput(\"A aula t√° legal? \") #recebe algum valor do terminal\n\n''\n\n\n\n\n2.5.2.4 Fun√ß√µes matem√°ticas e l√≥gicas\n\nabs() #m√≥dulo\ndivmod() #n√∫mero, divisor. resultado: (parte inteira, resto)\nmax()\nmin()\npow() #base, expoente\nround() #n√∫mero, d√≠gitos\nsum()\nall([True, True, False]) # True se todos os argumentos s√£o true\nany([True, True, False]) # True se pelo menos um argumento √© verdadeiro\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-1-e41fc4f9105a&gt; in &lt;cell line: 1&gt;()\n----&gt; 1 abs() #m√≥dulo\n      2 divmod() #n√∫mero, divisor. resultado: (parte inteira, resto)\n      3 max()\n      4 min()\n      5 pow() #base, expoente\n\nTypeError: abs() takes exactly one argument (0 given)\n\n\n\n\nabs(-3), abs(3)\n\n(3, 3)\n\n\n\ndivmod(7, 5)\n\n(1, 2)\n\n\n\nround(3.1263817241864518742612, 4)\n\n3.1264\n\n\n\n\n2.5.2.5 Fun√ß√µes relacionadas √† tipos de vari√°veis\n\nbin(10)\nhex(445125215) # n√∫meros hexadecimais\nint('1000', 2) # \"1000 base 2\"\nord('a'), chr(97) # o item numero 97 no 'dicion√°rio' UNICODE\nchr(ord('a'))\nord(chr(98))\n\n\n\n2.5.2.6 Fun√ß√µes sobre armazenamento de vari√°veis\n\na = 10 #lembre deste 10!\nrepr(dir())\n# repr: retorna um string do objeto\n# dir: todas os nomes no diret√≥rio atual\n\n\nrepr(dir([1,3]))\n\n\nlist(globals().items())[1:5]\n\n\ndict(list(globals().items()))\ndict(list(globals().items()))['__name__']\n\n\n\n2.5.2.7 Outras fun√ß√µes\n\nopen(file_path, mode) #abre um arquivo\n#Mode: 'r', 'w', 'x', 'a'; '+'; 'b' ou 't'\n# 'r' = read\n# 'w' = write\n# 'x' = Create\n# 'a' = Append\n# 'b' = Binary\n# 't' = Text\n\n\nhelp() #abre o prompt de ajuda no terminal\n\n\n\n\n2.5.3 Bibliotecas\n\n\n\n2.5.3.1 Como Instalar Bibliotecas\nRefer√™ncia: https://packaging.python.org/en/latest/tutorials/installing-packages/\nChecar instala√ß√£o do python (digitar no terminal): &gt; py ‚Äìversion\nChecar instala√ß√£o do pip, o instalador de pacotes: &gt; py -m pip ‚Äìversion\nInstalar o pacote pelo nome: &gt; py -m pip install nome_do_pacote\n\n\n2.5.3.2 M√≥dulo math\nRefer√™ncia: https://docs.python.org/3/library/math.html\n\nimport math\n\n\nround(math.pi, 3)\n\n\nmath.ceil()\nmath.floor()\nmath.trunc()\nmath.modf(5.256) #(0.2560000000000002, 5.0)\n\n\nmath.comb(k_items, n_op√ß√µes) #n! / (k! * (n - k)!) ) (sem ordem, sem repeti√ß√£o)\nmath.perm(k_items, n_op√ß√µes) #n! / (n - k)! (com ordem, sem repeti√ß√£o)\nmath.factorial(n)\n\n\nmath.gcd() #mdc\nmath.lcm() #mmc\n\n\n# abs(a-b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)\n# rel_tol = toler√¢ncia relativa\n# abs_tol = toler√¢ncia absoluta\nprint(math.isclose(5, 10, rel_tol=0.49, abs_tol=0))\nprint(math.isclose(5, 10, rel_tol=0, abs_tol=5))\n\n\nmath.isfinite()\nmath.isinf()\n\n\n\n2**(0.5), math.sqrt(2)\n\n\nprint(math.dist((0,0), [1,1])) # dist√¢ncia euclidiana\nprint(math.hypot(1,1,1,1,1)) # norma euclidiana ‚Üí dist√¢ncia da origem at√© o ponto\n\n\nmath.cos(), math.sin(), math.tan() #etc.\nmath.degrees(), math.radians() #convers√£o de um pro outro\n\n\nmath.e, math.pi, math.inf\n\n\n\n2.5.3.3 M√≥dulo statistics\nRefer√™ncia: https://docs.python.org/3/library/statistics.html\n\nimport statistics as stat\n\n\nstat.mean()\nstat.geometric_mean()\nstat.harmonic_mean()\nstat.median()\nstat.mode('aaabbb'), stat.multimode('aaabbbc') #('a', ['a', 'b'])\n\n\nstat.quantiles(iterable, n_quantis, method) #m√©todo 'inclusive' se a amostra tiver os maiores valores da popula√ß√£o, e 'exclusive' (default) c.c.\n\n\nstat.stdev(), stat.pstdev()\nstat.variance(), stat.pvariance()\n#vers√µes amostrais e populacionais, respectivamente\n\n\nstat.covariance()\nstat.correlation()\n\n\n\n2.5.3.4 M√≥dulo random\nRefer√™ncia: https://docs.python.org/3/library/random.html\n\nimport random as rd\n\n\nrd.seed(seed)\n\n\nrd.randint(1, 10), rd.random()\n\n\nrd.choices(my_list, weights=[0, 10, 80, 10], cum_weights=None, k=10)\n#rd.choices(my_list, weights=None, cum_weights=[0,m, 10, 90, 100], k=10)\n\n\nprint(my_list)\nrd.shuffle(my_list) #nenhum output\nmy_list #alterou a lista\n\n\nprint(rd.sample(my_list, len(my_list), counts=None)) #nova lista\nprint(my_list) #n√£o alterou a lista\nprint(rd.sample(my_list, 7, counts=[1, 2, 5, 2]))\n#a lista usada foi [3, 2, 2, 4, 4, 4, 4, 4, 1, 1]\n\n\nrd.uniform(2, 8)\nrd.gauss(mu, sigma)\n\n\n\n2.5.3.5 M√≥dulo os\nRefer√™ncias: https://docs.python.org/3/library/os.html, https://www.youtube.com/watch?v=tJxcKyFMTGo, https://www.programiz.com/python-programming/methods/built-in/repr\n\nimport os\n\n\n# \"repr()\"\n\n# O que √©: esta fun√ß√£o significa representation (representa√ß√£o). Ela retorna uma representa√ß√£o em string de um objeto que, idealmente, pode ser usada para recriar o objeto, facilitando a depura√ß√£o.\n\n# Para que serve: esta fun√ß√£o serve para inspecionarmos objetos, fornecendo uma representa√ß√£o de tudos os objetos. Tal inspecionamento √© conhecido como depura√ß√£o.\n\n# Ex.:\nnumbers = [1, 2, 3, 4, 5]\n# Output da lista printada\nprintable_numbers = repr(numbers)\nprint(printable_numbers)\n\n[1, 2, 3, 4, 5]\n\n\n\n# \"os.getcwd()\"\n\n# O que √©: esta fun√ß√£o significa \"get current working directory\" (obter o diret√≥rio de trabalho atual).\n  # √â uma fun√ß√£o da biblioteca os (sistema operacional) que retorna o caminho do diret√≥rio de trabalho atual, ou seja, o diret√≥rio em que o programa est√° sendo executado da pr√≥pria biblioteca os.\n\n# Para que serve: esta fun√ß√£o serve para descobrirmos/relembramos onde est√° o script no sistema de arquivos (arquivo de c√≥digo que usamos para programar em Python).\n\n# Ex. de comandos para executar essa fun√ß√£o:\n#diretorio_atual = os.getcwd() # 1) Comando para obtermos o diret√≥rio de trabalho atual\n\n#print(\"Diret√≥rio de Trabalho Atual:\", diretorio_atual) # # 2) Comando para imprimirmos o diret√≥rio de trabalho atual.\n                                                            # Nesse exemplo n√£o h√° diret√≥rio especificado, mas o seu nome apareceria antes de \"/content\" e depois dos dois pontos (\":\").\n\n\n# \"os.listdir()\"\n\n# O que √©: esta fun√ß√£o √© conhecida como \"listdir\" (list + diretory/ lista + diret√≥rio). √â uma fun√ß√£o da biblioteca os (sistema operacional).\n  # Ela retorna a lista com os nomes dos arquivos regulares e diret√≥rios contidos em um diret√≥rio especificado\n\n# Para que serve: esta fun√ß√£o serve para listarmos o conte√∫do de pastas no sistema de arquivos. Se nenhum diret√≥rio for especificado, ela usa o diret√≥rio de trabalho atual\n\n# Ex. de comandos para executar essa fun√ß√£o:\n#import os #1) Importamos a biblioteca necess√°ria para executar esta fun√ß√£o.\n\n#diretorio = '.' # 2) Comando para especificarmos o diret√≥rio (use '.' para o diret√≥rio atual).\n\n#conteudo = os.listdir(diretorio) # 3) Comando para obtermos a lista de arquivos regulares e diret√≥rios.\n\n#print(\"Conte√∫do do diret√≥rio:\", conteudo) # 4) Comando para imprimir a lista.\n\n\n# \"os.rmdir()\"\n\n# O que √©: a fun√ß√£o \"rmdir\" √© a abreviatura de \"remove\" + \"diretory\" (remover diret√≥rio). √â uma fun√ß√£o da biblioteca os (sistema operacional). Ela remove um diret√≥rio vazio.\n\n# Para que serve: esta fun√ß√£o serve para limpar diret√≥rios que n√£o cont√™m mais arquivos ou subdiret√≥rios. Se algum diret√≥rio n√£o estiver vazio, a fun√ß√£o apontar√° que n√£o foi poss√≠vel delet√°-lo.\n\n# Ex. de comandos para executar essa fun√ß√£o:\n\n#import os #1) Importamos a biblioteca necess√°ria para executar esta fun√ß√£o.\n\n#diretorio = 'diretorio_vazio' # 2) Especificamos o caminho do diret√≥rio que desejamos remover.\n\n#try: # 3) Op√ß√µes dos comandos para os poss√≠veis resultados:\n    #os.rmdir(diretorio)\n    #print(f\"O diret√≥rio '{diretorio}' foi removido com sucesso.\") # 3a) Comando para imprimir que tal diret√≥rio foi encontrado e removido.\n#except FileNotFoundError:\n    #print(f\"O diret√≥rio '{diretorio}' n√£o foi encontrado.\") # 3b) Comando para imprimir que tal diret√≥rio n√£o foi encontrado e por isso n√£o foi removido.\n#except OSError:\n    #print(f\"O diret√≥rio '{diretorio}' n√£o est√° vazio ou n√£o pode ser removido.\") # 3c) Comando para imprimir que tal diret√≥rio n√£o est√° vazio e por isso n√£o foi removido.\n\n\n# \"os.removedirs()\"\n\n# O que √©: a fun√ß√£o \"rmdir\" √© a abreviatura de \"remove\" + \"diretories\" (remover diret√≥rios).\n  # √â uma fun√ß√£o da biblioteca os (sistema operacional). Ela remove um diret√≥rio e todos os seus diret√≥rios \"pais\" (origin√°rios), se estiverem vazios\n\n# Para que serve: est√° fun√ß√£o serve para excluir uma estrutura de diret√≥rios de uma vez, desde o mais aparente (interno) at√© o externo, garantindo que todos os diret√≥rios vazios sejam removidos.\n  # Se algum diret√≥rio n√£o estiver vazio, a fun√ß√£o apontar√° que n√£o foi poss√≠vel delet√°-lo.\n\n# Ex. de comandos para executar essa fun√ß√£o:\n\n#import os #1) Importamos a biblioteca necess√°ria para executar esta fun√ß√£o.\n\n#os.makedirs('pasta/pasta_interna', exist_ok=True) # Criamos uma estrutura de diret√≥rios para executarmos o comando.\n\n#try: # 3) Op√ß√µes dos comandos para os poss√≠veis resultados:\n    #os.removedirs('pasta/pasta_interna')\n    #print(\"Diret√≥rios removidos com sucesso.\") # 3a) Comando para imprimir que tal parte da estrutura de diret√≥rios foi encontrada e removida.\n#except FileNotFoundError:\n  #print(\"Um ou mais diret√≥rios n√£o foram encontrados.\") # 3b) Comando para imprimir que tal parte da estrutura de diret√≥rio n√£o foi encontrada e por isso n√£o foi removida.\n#except OSError:\n    #print(\"Um ou mais diret√≥rios n√£o est√£o vazios ou n√£o podem ser removidos.\") # 3c) Comando para imprimir que tal parte da estrutura de diret√≥rio n√£o est√° vazia e por isso n√£o foi removida.\n\n\n# \"os.rename\"\n\n# O que √©: esta fun√ß√£o se chama \"rename\" (renomear). √â a fun√ß√£o da biblioteca os (sistema operacional) que renomeia arquivos ou diret√≥rios e os substitui pelo de mesmo nome.\n\n# Para que serve: ela pode ser usada para renomear um item (arquivo ou diret√≥rio), especificando o caminho atual e o novo nome desejado, e tamb√©m para susbtituir arquivos.\n  # Sua principal utilidade √© organizacional: dos arquivos e dos diret√≥rios no sistema de arquivos.\n\n# 1. Ex.: comandos para renomear itens:\n\n#import os #1) Importamos a biblioteca necess√°ria para executar esta fun√ß√£o.\n\n# item_antigo = 'item_original.txt' # 2a) Especificamos o nome antigo que desejamos renomear.\n# item_novo = 'item_renomeado.txt' # 2b) Especificamos o nome novo que desejamos renomear.\n\n# try: # 3) Op√ß√µes dos comandos para os poss√≠veis resultados:\n    #os.rename(item_antigo, item_novo)\n    #print(f\"O arquivo foi renomeado para '{item_novo}'.\") # 3a) Comando para imprimir que tal item n√£o foi encontrado\n#except FileNotFoundError:\n    #print(f\"O item '{item_antigo}' n√£o foi encontrado.\") # 3b) Comando para imprimir que tal item n√£o foi encontrado e por isso n√£o foi renomeado.\n#except OSError:\n    #print(f\"O item '{item_antigo}' n√£o est√° vazio ou n√£o pode ser removido.\") # 3c) Comando para imprimir que tal item n√£o existe e por isso n√£o foi renomeado.\n\n# 2. Ex.: comandos para substituir itens:\n\n#import os #1) Importamos a biblioteca necess√°ria para executar esta fun√ß√£o.\n\n# item_antigo = 'item_original.txt' # 2a) Especificamos o nome antigo que desejamos substiruir. Lembre que √© necess√°rio especificar o tipo de item para a entendermos melhor o que o comando ir√° fazer.\n# item_novo = 'item_substituto.txt' # 2b) Especificamos o nome novo que desejamos substiruir. Lembre que √© necess√°rio especificar o tipo de item para a entendermos melhor o que o comando ir√° fazer.\n\n# try: # 4) Op√ß√µes dos comandos para os poss√≠veis resultados:\n    #os.rename(item_antigo, item_novo)\n    #print(f\"O arquivo foi substitu√≠do para '{item_novo}'.\") # 4a) Comando para imprimir que tal item foi encontrado e substitu√≠do.\n#except FileNotFoundError:\n    #print(f\"O item '{item_antigo}' n√£o foi encontrado.\") # 4b) Comando para imprimir que tal item n√£o foi encontrado e por isso n√£o foi substitu√≠do.\n#except OSError:\n    #print(f\"O item '{item_antigo}' n√£o est√° vazio ou n√£o pode ser removido.\") # 3c) Comando para imprimir que tal item n√£o existe e por isso n√£o foi substitu√≠do.\n\n\n# \"os.stat\"\n\n# O que √©: esta fun√ß√£o √© um m√©todo do objeto de caminho da biblioteca os ou da biblioteca pathlib que retorna informa√ß√µes sobre um arquivo regular ou diret√≥rio, como tamanho, permiss√µes, data de modifica√ß√£o, etc.\n  #  Essa fun√ß√£o fornece um objeto que cont√©m v√°rios atributos, permitindo acessar detalhes espec√≠ficos sobre o arquivo regular ou diret√≥rio em quest√£o.\n\n# Para que serve: esta fun√ß√£o serve para obtermos metadados (dados de dados) sem precisar abrir o arquivo. Tais metadados s√£o importantes para entendemos melhor atributos de um dado e n√£o seu conte√∫do.\n\n# Ex. de comandos para executar essa fun√ß√£o:\n\n#import os\n#import time #1) Importamos as bibliotecas necess√°rias para executarmos esta fun√ß√£o.\n\n#arquivo = 'exemplo.txt' # 2) Especificamos o nome do arquivo para o qual desejamos obter informa√ß√µes.\n\n#info = os.stat(arquivo) 3) Comando para sinalizarmos que queremos obter informa√ß√µes sobre o arquivo (metadados do arquivo).\n\n#print(\"Tamanho do arquivo:\", info.st_size, \"bytes\") # 4) Comando para imprimirmos o tamanho do arquivo.\n#print(f\"Data da √∫ltima modifica√ß√£o: {time.ctime(info.st_mtime)}\") # 5) Comando para imprimirmos data e hora da √∫ltima modifica√ß√£o.\n#print(f\"Permiss√µes do arquivo: {oct(info.st_mode)}\") # 6) Comando para imprimirmos as permiss√µes do arquivo.\n# 7) Comando para verificarmos qual o tipo de arquivo:\n#if stat.S_ISDIR(info.st_mode):\n    #print(f\"{info} √© um diret√≥rio.\") # 7a) Comando para descobrimos se √© um diret√≥rio.\n#elif stat.S_ISREG(info.st_mode):\n    #print(f\"{info} √© um arquivo.\") # 7b) Comando para descobrirmos se √© um arquivo regular.\n#else:\n    #print(f\"{info} √© de um tipo desconhecido.\") # 7c) Comando para o c√≥digo n√£o travar se n√£o for arquivo regular ou diret√≥rio o arquivo que est√° sendo analisado.\n\n\n\n2.5.3.6 M√≥dulo ScyPy\nRefer√™ncias: https://docs.scipy.org/doc/scipy/tutorial/index.html#user-guide\n\nEstat√≠stica: https://scipy.github.io/devdocs/reference/stats.html\nOtimiza√ß√£o: https://scipy.github.io/devdocs/reference/optimize.html\n√Ålgebra linear: https://scipy.github.io/devdocs/reference/linalg.html\nInterpola√ß√£o: https://scipy.github.io/devdocs/reference/generated/scipy.interpolate.interp1d.html#scipy.interpolate.interp1d\n\n\nimport scipy.stats # √© um m√≥dulo da biblioteca SciPy em Python que fornece uma ampla gama de fun√ß√µes e classes para trabalhar com estat√≠sticas e distribui√ß√µes de probabilidade.\n\n\n# O que √©: esta fun√ß√£o do m√≥dulo scipy.stats que realiza uma regress√£o linear entre duas vari√°veis\n\n# Para que serve: esta fun√ß√£o retorna v√°rias informa√ß√µes √∫teis sobre a rela√ß√£o linear entre os dados.\n\n# Ex. de comandos para executarmos essa fun√ß√£o\n   # n√£o precisamos conversar agora a fundo sobre essas analises, pois veremos na segunda parte do trainee.\n\n#import numpy as np # 0) biblioteca que veremos na pr√≥xima aula.\n#from scipy import stats # 1) Importamos as bibliotecas necess√°rias para executarmos esta fun√ß√£o.\n\n#x = np.array([1, 2, 3, 4, 5])\n#y = np.array([2, 3, 5, 7, 11]) # 2) Definimos os n√∫meros naturais em cada eixo de uma plano bidimensional.\n\n#print(\"Resultados da Regress√£o Linear:\") # 3) Comando para imprimirmos t√≠tulo das an√°lises.\n#print(f\"Inclina√ß√£o (slope): {slope}\") # 3a) Comando para imprimir an√°lise em slope.\n#print(f\"Intercepto (intercept): {intercept}\") # 3b) Comando para imprimimos an√°lise de intercep√ß√£o.\n#print(f\"Coeficiente de Correla√ß√£o (r-value): {r_value}\") # 3c) Comando para imprimirmos an√°lise de coeficiente de correla√ß√£o.\n#print(f\"Valor de p (p-value): {p_value}\") # 3d) Comando para imprimirmos an√°lise de valor de p.\n#print(f\"Erro Padr√£o (std_err): {std_err}\") # 3e) Comando para c√≥digo n√£o n√£o travar se tiver algum erro.\n\nAqui, as fun√ß√µes menos essenciais, de consulta para voc√™s.\nRefer√™ncia: https://docs.python.org/3/library/functions.html",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Introdu√ß√£o ao Python II</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GVCode Trainee",
    "section": "",
    "text": "Bem Vindos!\nEste √© o material do curso de Trainee da GVCode. Cada cap√≠tulo est√° associado a uma aula presencial.\nEsse material foi 100% escrito pelos veteranos da entidade, e est√° sendo otimizado desde 2020! Ao final, temos algumas das bibliografias utilizadas em sua confec√ß√£o.",
    "crumbs": [
      "Bem Vindos!"
    ]
  },
  {
    "objectID": "index.html#aulas",
    "href": "index.html#aulas",
    "title": "GVCode Trainee",
    "section": "Aulas",
    "text": "Aulas\nIntrodu√ß√£o ao Python I\n\nO que √© um script; sintaxe; vari√°veis; tipos de dados.\nOperadores; control flow; fun√ß√µes.\nExtra: f-strings; condi√ß√µes (try except).\n\nIntrodu√ß√£o ao Python II\n\nPrograma√ß√£o orientada ao objeto.\nCole√ß√µes (list, dict, tuple, set); subsetting e m√©todos.\nIter√°veis loops, comprehension, e enumerate, filter, zip, e map.\nExtra: *args; fun√ß√µes √∫teis.\n\nIntrodu√ß√£o ao Python III\n\nNumpy: arrays e vetoriza√ß√£o; opera√ß√µes e subsetting.\nPandas: dataframes; opera√ß√µes.\nExtra: t√≥picos avan√ßados em Numpy e Pandas.\n\nCi√™ncia de Dados: Manipula√ß√£o\n\nIntrodu√ß√£o √† ci√™ncia de dados; o que √© processamento de dados.\nComo arrumar dados com Pandas.\n\nCi√™ncia de Dados: Visualiza√ß√£o\n\nO que √© visualiza√ß√£o de dados.\nSumariza√ß√£o com Pandas; Gr√°ficos com o Matplotlib.\nExtra: seaborn e outras bibliotecas; gr√°ficos avan√ßados.\n\nCi√™ncia de Dados: Modelagem\n\nO que √© modelagem de dados.\nAula te√≥rica sobre modelos de machine learning.\n\nCi√™ncia de Dados: Projetos\n\nEtapas e exemplo de um script de ci√™ncia de dados.\nFun√ß√µes de modelagem.\nExtra: apresentar trabalho.\n\nOutros Temas em Programa√ß√£o\n\nGit e Github.\nBoas pr√°ticas de programa√ß√£o (python‚Äôs pep8).\nExtra: regex; web scrapping.",
    "crumbs": [
      "Bem Vindos!"
    ]
  }
]